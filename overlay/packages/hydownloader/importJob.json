{
  "sourceHash": "sha256-/Q3N9eu8OSiAqDY40jajfFggjrEzW7Z4UQo77e34Rpk=",
  "commonConfig": "#\n# Some common values used in the default import job\n# You probably want to change these\n#\n\ndefAPIURL = \"http://127.0.0.1:45869\"\ndefAPIKey = \"your Hydrus API key here\"\ndefTagRepos = [\"my tags\"]\ndefTagReposForNonUrlSources = [\"my tags\"]\n# These are the defaults that Hydrus automatically creates,\n# you'll have to add here any others that appear in the importer configuration.\n# You can get the key from Hydrus in the review services window.\ndefServiceNamesToKeys = {\n    \"my tags\": \"6c6f63616c2074616773\",\n    \"local tags\": \"6c6f63616c2074616773\",\n    \"downloader tags\": \"646f776e6c6f616465722074616773\"\n}\n# This function will be applied to the final results generated from each file\n# You can implement any global blacklists/whitelists or transformations here\ndef defGlobalResultFilter(abspath: str, json_data: dict, tags: set[tuple[str, str]], urls: list[str], notes: set[tuple[str, str]], domain_times: dict[str, datetime]):\n    return tags, urls, notes, domain_times\n\n",
  "defaultImportJob": "#\n# Default import job - main config\n#\n\nj = ImportJob(name = \"default\",\n              apiURL = defAPIURL,\n              apiKey = defAPIKey,\n              usePathBasedImport = False,\n              overridePathBasedLocation = \"\",\n              orderFolderContents = \"name\",\n              nonUrlSourceNamespace = \"hydl-non-url-source\",\n              serviceNamesToKeys = defServiceNamesToKeys,\n              globalResultFilter = defGlobalResultFilter)\n\n",
  "defaultRules": "#\n# Default import job - generic tag/URL rules (applicable for all sites)\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: True)\n\ng.tags(name = 'hydownloader import job datetime', tagRepos = defTagRepos).values(lambda: 'hydl-import-time:'+import_start_datetime)\n\ng.tags(name = 'additional tags (with tag repo specified)', allowNoResult = True) \\\n .values(lambda: [repo+':'+tag for (repo,tag) in get_namespaces_tags(extra_tags, '', None) if repo != '' and repo != 'urls'])\n\ng.tags(name = 'additional tags (without tag repo specified)', tagRepos = defTagRepos, allowNoResult = True) \\\n .values(lambda: extra_tags[''] if '' in extra_tags else [])\n\ng.tags(name = 'hydownloader IDs', tagRepos = defTagRepos) \\\n .values(lambda: ['hydl-sub-id:'+s_id for s_id in sub_ids]) \\\n .values(lambda: ['hydl-url-id:'+u_id for u_id in url_ids])\n\ng.tags(name = 'hydownloader source site', tagRepos = defTagRepos) \\\n .values(lambda: 'hydl-src-site:'+json_data['category'])\n\ng.urls(name = 'additional URLs', allowNoResult = True) \\\n .values(lambda: extra_tags['urls'])\n\ng.urls(name = 'source URLs from single URL queue', allowNoResult = True) \\\n .values(lambda: single_urls)\n\ng.urls(name = 'gallery-dl file url', allowEmpty = True) \\\n .values(lambda: (u := json_data.get('gallerydl_file_url', '')) and ('' if u.startswith('text:') else u))\n\n\n",
  "rules": {
    "pixiv": "#\n# Rules for pixiv\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/pixiv/'))\n\ng.tags(name = 'pixiv tags (original), new json format', tagRepos = defTagRepos, allowNoResult = True, allowTagsEndingWithColon = True) \\\n .values(lambda: [(tag if type(tag) is str else tag['name']) for tag in json_data['tags']] if not 'untranslated_tags' in json_data else [])\n\ng.tags(name = 'pixiv tags (translated), new json format', tagRepos = defTagRepos, allowNoResult = True, allowTagsEndingWithColon = True) \\\n .values(lambda: [tag['translated_name'] for tag in json_data['tags'] if type(tag) is not str and tag['translated_name'] is not None] if not 'untranslated_tags' in json_data else [])\n\ng.tags(name = 'pixiv tags (original), old json format', tagRepos = defTagRepos, allowNoResult = True, allowTagsEndingWithColon = True) \\\n .values(lambda: json_data['untranslated_tags'] if 'untranslated_tags' in json_data else [])\n\ng.tags(name = 'pixiv tags (translated), old json format', tagRepos = defTagRepos, allowNoResult = True, allowTagsEndingWithColon = True) \\\n .values(lambda: json_data['tags'] if 'untranslated_tags' in json_data else [])\n\ng.tags(name = 'pixiv generated tags', tagRepos = defTagRepos) \\\n .values(lambda: 'page:'+str(int(json_data['suffix'][2:])+1) if json_data['suffix'] else 'page:1') \\\n .values(lambda: 'pixiv work:'+str(json_data['id'])) \\\n .values(lambda: 'creator:'+json_data['user']['account']) \\\n .values(lambda: 'creator:'+json_data['user']['name']) \\\n .values(lambda: 'rating:'+json_data['rating']) \\\n .values(lambda: 'pixiv id:'+str(json_data['user']['id']))\n\ng.tags(name = 'pixiv generated tags (title)', tagRepos = defTagRepos, allowEmpty = True, allowTagsEndingWithColon = True) \\\n .values(lambda: ('title:'+json_data['title']) if json_data['title'] and json_data['title'].strip() else '')\n\ng.urls(name = 'pixiv artwork url') \\\n .values(lambda: 'https://www.pixiv.net/en/artworks/'+str(json_data['id']))\n\n",
    "nijie": "#\n# Rules for nijie.info\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/nijie/'))\n\ng.tags(name = 'nijie tags', tagRepos = defTagRepos, allowNoResult = True) \\\n .values(lambda: json_data['tags'])\n\ng.tags(name = 'nijie generated tags', tagRepos = defTagRepos) \\\n .values(lambda: 'title:'+json_data['title']) \\\n .values(lambda: 'page:'+str(json_data['num'])) \\\n .values(lambda: 'nijie id:'+str(json_data['image_id'])) \\\n .values(lambda: 'creator:'+json_data['artist_name']) \\\n .values(lambda: 'nijie artist id:'+str(json_data['artist_id']))\n\ng.urls(name = 'nijie urls') \\\n .values(lambda: 'https://nijie.info/view.php?id='+str(json_data['image_id'])) \\\n .values(lambda: json_data['url'])\n\n",
    "patreon": "#\n# Rules for Patreon\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/patreon/'))\n\ng.tags(name = 'patreon generated tags', tagRepos = defTagRepos) \\\n .values(lambda: 'page:'+str(json_data['num'])) \\\n .values(lambda: 'patreon id:'+str(json_data['id'])) \\\n .values(lambda: 'creator:'+json_data['creator']['full_name']) \\\n .values(lambda: 'creator:'+json_data['creator']['vanity']) \\\n .values(lambda: 'patreon artist id:'+str(json_data['creator']['id']))\n\ng.tags(name = 'patreon generated tags (title)', tagRepos = defTagRepos, allowEmpty = True, allowTagsEndingWithColon = True) \\\n .values(lambda: ('title:'+json_data['title']) if json_data['title'] and json_data['title'].strip() else '')\n\ng.urls(name = 'patreon urls') \\\n .values(lambda: json_data['url'])\n\n",
    "newgrounds": "#\n# Rules for Newgrounds\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/newgrounds/'))\n\ng.tags(name = 'newgrounds tags', tagRepos = defTagRepos, allowNoResult = True) \\\n .values(lambda: json_data['tags'])\n\ng.tags(name = 'newgrounds generated tags', tagRepos = defTagRepos) \\\n .values(lambda: 'title:'+json_data['title']) \\\n .values(lambda: 'creator:'+json_data['user']) \\\n .values(lambda: 'rating:'+json_data['rating']) \\\n .values(lambda: ('creator:'+artist for artist in json_data['artist']))\n\ng.urls(name = 'newgrounds url') \\\n .values(lambda: json_data['url'])\n\ng.urls(name = 'newgrounds post url') \\\n .values(lambda: json_data['post_url'])\n\n",
    "mastodon": "#\n# Rules for Mastodon instances\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/mastodon/'))\n\ng.tags(name = 'mastodon tags', tagRepos = defTagRepos, allowNoResult = True) \\\n .values(lambda: json_data['tags'])\n\ng.tags(name = 'mastodon generated tags', tagRepos = defTagRepos) \\\n .values(lambda: 'mastodon instance:'+json_data['instance']) \\\n .values(lambda: 'mastodon id:'+str(json_data['id'])) \\\n .values(lambda: 'creator:'+json_data['account']['username']) \\\n .values(lambda: 'creator:'+json_data['account']['acct']) \\\n .values(lambda: 'creator:'+json_data['account']['display_name'])\n\ng.urls(name = 'mastodon urls') \\\n .values(lambda: json_data['url']) \\\n .values(lambda: json_data['uri'])\n\n\n",
    "misskey": "#\n# Rules for misskey instances\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/misskey/'))\n\ng.tags(name = 'misskey tags', tagRepos = defTagRepos, allowNoResult = True) \\\n .values(lambda: json_data['tags'] if 'tags' in json_data else [])\n\ng.tags(name = 'misskey generated tags', tagRepos = defTagRepos) \\\n .values(lambda: 'misskey instance:'+json_data['instance']) \\\n .values(lambda: 'misskey id:'+str(json_data['id'])) \\\n .values(lambda: 'creator:'+json_data['user']['username']) \\\n .values(lambda: 'misskey user id:'+json_data['userId']) \\\n .values(lambda: 'misskey file id:'+json_data['file']['id'])\n\ng.tags(name = 'misskey generated tags', tagRepos = defTagRepos, skipOnError = True) \\\n .values(lambda: 'creator:'+json_data['user']['name'])\n\ng.urls(name = 'misskey urls') \\\n .values(lambda: json_data['file']['url']) \\\n .values(lambda: 'https://'+json_data['instance']+'/notes/'+json_data['id'])\n\n\n",
    "webtoons": "#\n# Rules for WebToons\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/webtoons/'))\n\ng.tags(name = 'webtoons generated tags', tagRepos = defTagRepos) \\\n .values(lambda: 'webtoons comic:'+json_data['comic']) \\\n .values(lambda: 'chapter number:'+json_data['episode']) \\\n .values(lambda: 'chapter:'+json_data['title']) \\\n .values(lambda: 'page:'+str(json_data['num']))\n\ng.urls(name = 'webtoons urls') \\\n .values(lambda: 'https://www.webtoons.com/'+json_data['lang']+'/'+json_data['genre']+'/'+json_data['comic']+'/list?title_no='+json_data['title_no'])\n\n",
    "danbooru": "#\n# Rules for danbooru\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/danbooru/'))\n\ng.tags(name = 'danbooru generated tags', tagRepos = defTagRepos, allowEmpty = True) \\\n .values(lambda: 'danbooru id:'+str(json_data['id'])) \\\n .values(lambda: 'booru:danbooru') \\\n .values(lambda: 'rating:'+json_data['rating']) \\\n .values(lambda: ('pixiv work:'+str(json_data['pixiv_id'])) if json_data['pixiv_id'] else '')\n\ng.domain_time('danbooru.donmai.us', lambda: json_data['created_at'])\n\ng.tags(name = 'danbooru tags', tagRepos = defTagRepos, allowTagsEndingWithColon = True) \\\n .values(lambda: [(key+':'+tag if key != 'general' else tag) for (key, tag) in get_namespaces_tags(json_data, 'tag_string_')])\n\ng.urls(name = 'danbooru urls', allowEmpty = True) \\\n .values(lambda: json_data['file_url']) \\\n .values(lambda: json_data['large_file_url']) \\\n .values(lambda: 'https://danbooru.donmai.us/posts/'+str(json_data['id'])) \\\n .values(lambda: json_data['source'])\n\n",
    "aibooru": "#\n# Rules for aibooru\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/aibooru/'))\n\ng.tags(name = 'aibooru generated tags', tagRepos = defTagRepos, allowEmpty = True) \\\n .values(lambda: 'aibooru id:'+str(json_data['id'])) \\\n .values(lambda: 'booru:aibooru') \\\n .values(lambda: ('pixiv work:'+str(json_data['pixiv_id'])) if json_data['pixiv_id'] else '')\n\ng.domain_time('aibooru.online', lambda: json_data['created_at'])\n\ng.tags(name = 'aibooru tags', tagRepos = defTagRepos, allowTagsEndingWithColon = True) \\\n .values(lambda: [(key+':'+tag if key != 'general' else tag) for (key, tag) in get_namespaces_tags(json_data, 'tag_string_')])\n\ng.urls(name = 'aibooru urls', allowEmpty = True) \\\n .values(lambda: json_data['file_url']) \\\n .values(lambda: json_data['large_file_url']) \\\n .values(lambda: 'https://aibooru.online/posts/'+str(json_data['id'])) \\\n .values(lambda: json_data['source'])\n\n",
    "atfbooru": "#\n# Rules for atfbooru\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/atfbooru/'))\n\ng.tags(name = 'atfbooru generated tags', tagRepos = defTagRepos, allowEmpty = True) \\\n .values(lambda: 'atfbooru id:'+str(json_data['id'])) \\\n .values(lambda: 'booru:atfbooru') \\\n .values(lambda: ('pixiv work:'+str(json_data['pixiv_id'])) if json_data['pixiv_id'] else '')\n\ng.tags(name = 'atfbooru tags', tagRepos = defTagRepos, allowTagsEndingWithColon = True) \\\n .values(lambda: [(key+':'+tag if key != 'general' else tag) for (key, tag) in get_namespaces_tags(json_data, 'tag_string_')])\n\ng.urls(name = 'atfbooru urls', allowEmpty = True) \\\n .values(lambda: json_data['file_url']) \\\n .values(lambda: json_data['large_file_url']) \\\n .values(lambda: 'https://booru.allthefallen.moe/posts/'+str(json_data['id'])) \\\n .values(lambda: json_data['source'])\n\n",
    "gelbooru": "#\n# Rules for gelbooru\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/gelbooru/'))\n\ng.tags(name = 'gelbooru generated tags', tagRepos = defTagRepos, allowEmpty = True) \\\n .values(lambda: 'gelbooru id:'+str(json_data['id'])) \\\n .values(lambda: 'booru:gelbooru') \\\n .values(lambda: 'rating:'+json_data['rating']) \\\n .values(lambda: ('title:'+json_data['title']) if json_data['title'] and json_data['title'].strip() else '')\n\ng.domain_time('gelbooru.com', lambda: json_data['created_at'])\n\ng.tags(name = 'gelbooru tags', tagRepos = defTagRepos, allowTagsEndingWithColon = True) \\\n .values(lambda: [(key+':'+tag if key != 'general' else tag) for (key, tag) in get_namespaces_tags(json_data, 'tags_')])\n\ng.urls(name = 'gelbooru urls', allowEmpty = True) \\\n .values(lambda: json_data['file_url']) \\\n .values(lambda: 'https://gelbooru.com/index.php?page=post&s=view&id='+str(json_data['id'])) \\\n .values(lambda: json_data['source'])\n\n",
    "sankaku": "#\n# Rules for Sankaku\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/sankaku/'))\n\ng.tags(name = 'sankaku generated tags', tagRepos = defTagRepos, allowEmpty = True) \\\n .values(lambda: 'sankaku id:'+str(json_data['id'])) \\\n .values(lambda: 'booru:sankaku') \\\n .values(lambda: 'rating:'+json_data['rating'])\n\ng.tags(name = 'sankaku tags', tagRepos = defTagRepos, allowTagsEndingWithColon = True) \\\n .values(lambda: [(key+':'+tag if key != 'general' else tag) for (key, tag) in get_namespaces_tags(json_data, 'tags_', None)])\n# old, broken since they started using spaces instead of _ inside tags in these strings\n# .values(lambda: [(key+':'+tag if key != 'general' else tag) for (key, tag) in get_namespaces_tags(json_data, 'tag_string_')])\n\ng.urls(name = 'sankaku urls', allowEmpty = True) \\\n .values(lambda: json_data['file_url']) \\\n .values(lambda: 'https://chan.sankakucomplex.com/en/posts/'+str(json_data['id'])) \\\n .values(lambda: json_data['source'] if json_data['source'] else '')\n\n",
    "sankakuIdolcomplex": "#\n# Rules for Sankaku idolcomplex\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/idolcomplex/'))\n\ng.tags(name = 'idolcomplex generated tags', tagRepos = defTagRepos, allowEmpty = True) \\\n .values(lambda: 'idolcomplex id:'+str(json_data['id'])) \\\n .values(lambda: 'booru:idolcomplex') \\\n .values(lambda: 'rating:'+json_data['rating'])\n\ng.tags(name = 'idolcomplex tags', tagRepos = defTagRepos) \\\n .values(lambda: [(key+':'+tag if key != 'general' else tag) for (key, tag) in get_namespaces_tags(json_data, 'tags_')])\n\ng.urls(name = 'idolcomplex urls', allowEmpty = True) \\\n .values(lambda: json_data['file_url']) \\\n .values(lambda: 'https://idol.sankakucomplex.com/post/show/'+str(json_data['id']))\n\n",
    "hentaiFoundry": "#\n# Rules for HentaiFoundry\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/hentaifoundry/'))\n\ng.tags(name = 'hentaifoundry generated tags', tagRepos = defTagRepos) \\\n .values(lambda: 'title:'+json_data['title']) \\\n .values(lambda: 'medium:'+json_data['media'] if 'media' in json_data else [])\n\ng.tags(name = 'hentaifoundry tags', tagRepos = defTagRepos) \\\n .values(lambda: [tag.replace('_',' ') for tag in json_data['tags']] if 'tags' in json_data else []) \\\n .values(lambda: json_data['ratings'])\n\ng.urls(name = 'hentaifoundry urls') \\\n .values(lambda: json_data['src']) \\\n .values(lambda: 'https://www.hentai-foundry.com/pictures/user/'+json_data['user']+'/'+str(json_data['index']))\n\n",
    "deviantArt": "#\n# Rules for Deviantart\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/deviantart/'))\n\ng.tags(name = 'deviantart generated tags', tagRepos = defTagRepos) \\\n .values(lambda: 'title:'+json_data['title']) \\\n .values(lambda: 'creator:'+json_data['username'])\n\ng.tags(name = 'deviantart tags', tagRepos = defTagRepos, allowNoResult = True) \\\n .values(lambda: json_data['tags'])\n\ng.urls(name = 'deviantart urls', allowEmpty = True) \\\n .values(lambda: json_data['content']['src'] if 'content' in json_data else '') \\\n .values(lambda: json_data['target']['src'] if 'target' in json_data else '') \\\n .values(lambda: json_data['url'])\n\n",
    "twitter": "#\n# Rules for Twitter\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/twitter/') and pathlen(path) > 3)\n\ng.tags(name = 'twitter generated tags', tagRepos = defTagRepos) \\\n .values(lambda: 'creator:'+json_data['author']['name']) \\\n .values(lambda: 'creator:'+json_data['author']['nick']) \\\n .values(lambda: 'creator:'+str(json_data['author']['id'])) \\\n .values(lambda: 'tweet id:'+str(json_data['tweet_id']))\n\ng.urls(name = 'twitter urls') \\\n .values(lambda: 'https://twitter.com/i/status/'+str(json_data['tweet_id'])) \\\n .values(lambda: 'https://twitter.com/'+json_data['author']['name']+'/status/'+str(json_data['tweet_id']))\n\n#g.tags(name = 'extra twitter generated tags', tagRepos = defTagRepos, allowEmpty = True) \\\n# .values(lambda: 'image:'+str(json_data['num']) if json_data['count'] > 1 else '') \\\n# .values(lambda: 'reply to:' + json_data['reply_to'] if 'reply_to' in json_data else '') \\\n# .values(lambda: 'twitter_gif' if ('bitrate' in json_data and json_data['bitrate'] == 0) else '') \\\n# .values(lambda: 'source:twitter.com')\n\ng.tags(name = 'tweet hashtags', tagRepos = defTagRepos, allowEmpty = True, ) \\\n.values(lambda: ['tweet hashtag:' + hashtag for hashtag in json_data['hashtags']] if 'hashtags' in json_data else '')\n\ng.notes(name = 'tweet text', allowEmpty = True) \\\n .values(lambda: \"tweet text\\n\"+json_data['content'])\n\ng.domain_time('x.com', lambda: json_data['date'])\ng.domain_time('twitter.com', lambda: json_data['date'])\n\n",
    "bluesky": "#\n# Rules for Bluesky\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/bluesky/'))\n\ng.tags(name = 'bluesky generated tags', tagRepos = defTagRepos) \\\n .values(lambda: 'creator:'+json_data['author']['handle']) \\\n .values(lambda: 'bluesky instance:'+json_data['instance']) \\\n .values(lambda: json_data['hashtags']) \\\n .values(lambda: 'bluesky post id:'+json_data['post_id'])\n\ng.tags(name = 'bluesky author display name', tagRepos = defTagRepos, allowEmpty = True) \\\n .values(lambda: 'creator:'+json_data['author']['displayName'] if json_data['author']['displayName'] else '')\n\ng.urls(name = 'bluesky urls') \\\n .values(lambda: \"https://\"+json_data['instance']+\"/profile/\"+json_data['user']['handle']+\"/post/\"+json_data['post_id'])\n\ng.notes(name = 'bluesky post text and description', allowEmpty = True) \\\n .values(lambda: \"post text\\n\"+json_data['text']) \\\n .values(lambda: \"post description\\n\"+json_data['description'])\n\ng.domain_time(lambda: json_data['instance'], lambda: json_data['createdAt'])\n\n",
    "kemonoParty": "#\n# Rules for kemono.party\n#\n\n# everything but discord (discord entries lack most of the metadata used here)\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: (pstartswith(path, 'gallery-dl/kemonoparty/') or pstartswith(path, 'gallery-dl/kemono/')) and json_data['subcategory'] != 'discord')\n\ng.tags(name = 'kemonoparty generated tags', tagRepos = defTagRepos, allowEmpty = True) \\\n .values(lambda: 'title:'+json_data['title']) \\\n .values(lambda: 'creator:'+json_data['username'] if 'username' in json_data else '') \\\n .values(lambda: 'kemono.party service:'+json_data['service']) \\\n .values(lambda: 'kemono.party id:'+json_data['id']) \\\n .values(lambda: 'kemono.party user id:'+json_data['user']) \\\n .values(lambda: '{} id:{}'.format(('pixiv' if json_data['service'] == 'fanbox' else json_data['service']), json_data['user']))\n\n# non-discord post URL\ng.urls(name='kemono post url') \\\n .values(lambda: 'https://kemono.cr/' + json_data['service'] + '/user/' + json_data['user'] + '/post/' + json_data['id'])\n\n# discord\ng = j.group(filter=lambda: pstartswith(path, 'gallery-dl/kemonoparty/discord/') or pstartswith(path, 'gallery-dl/kemono/discord/'))\n\ng.tags(name='kemonoparty discord generated tags', tagRepos = defTagRepos, allowNoResult = True, allowTagsEndingWithColon = True) \\\n .values(lambda: json_value_with_namespace(json_data, 'id', 'discord post id')) \\\n .values(lambda: 'page:{}'.format(json_data['num']) if json_data['type'] in {'attachment', 'inline'} else ()) \\\n .values(lambda: 'filename:{}'.format(json_data['filename']) if 'filename' in json_data else ()) \\\n .values(lambda: json_value_with_namespace(json_data, 'channel_name', 'discord channel')) \\\n .values(lambda: json_value_with_namespace(json_data, 'server', 'discord server')) \\\n .values(lambda: 'uploader:' + json_data['author']['username'])\n# the following adds whoever posted the image to discord as creator, which isn't necessarily the same as the actual creator\n# add this rule at your own risk\n# .values(lambda: 'creator:' + json_data['author']['username'])\n\ng.urls(name='kemono discord post url') \\\n .values(lambda: 'https://kemono.cr/discord/server/{}'.format(json_data['server']))\n\n",
    "coomerParty": "#\n# Rules for coomer.party\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/coomerparty/') or pstartswith(path, 'gallery-dl/coomer/'))\n\ng.tags(name = 'coomerparty generated tags', tagRepos = defTagRepos) \\\n .values(lambda: 'title:'+json_data['title']) \\\n .values(lambda: 'person:'+json_data['username']) \\\n .values(lambda: 'coomer.party service:'+json_data['service']) \\\n .values(lambda: 'coomer.party id:'+json_data['id']) \\\n .values(lambda: 'coomer.party user id:'+json_data['user'])\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/directlink/'))\n\ng.urls(name = 'directlink url') \\\n .values(lambda: clean_url('https://'+json_data['domain']+'/'+json_data['path']+'/'+json_data['filename']+'.'+json_data['extension']))\n\n",
    "_3dbooru": "#\n# Rules for 3dbooru\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/3dbooru/'))\n\ng.tags(name = '3dbooru generated tags', tagRepos = defTagRepos) \\\n .values(lambda: 'creator:'+json_data['author']) \\\n .values(lambda: 'booru:3dbooru') \\\n .values(lambda: '3dbooru id:'+str(json_data['id'])) \\\n .values(lambda: 'rating:'+json_data['rating'])\n\ng.tags(name = '3dbooru tags', tagRepos = defTagRepos) \\\n .values(lambda: [(key+':'+tag if key != 'general' else tag) for (key, tag) in get_namespaces_tags(json_data)])\n\ng.urls(name = '3dbooru URLs') \\\n .values(lambda: json_data['file_url']) \\\n .values(lambda: 'http://behoimi.org/post/show/'+str(json_data['id']))\n\n",
    "safebooru": "#\n# Rules for safebooru\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/safebooru/'))\n\ng.tags(name = 'safebooru generated tags', tagRepos = defTagRepos) \\\n .values(lambda: 'safebooru id:'+json_data['id']) \\\n .values(lambda: 'booru:safebooru') \\\n .values(lambda: 'rating:'+json_data['rating'])\n\ng.domain_time('safebooru.org', lambda: json_data['created_at'])\n\ng.tags(name = 'safebooru tags', tagRepos = defTagRepos) \\\n .values(lambda: map(lambda x: x.strip().replace('_', ' '),json_data['tags'].strip().split(' ')))\n\ng.urls(name = 'safebooru URLs', allowEmpty = True) \\\n .values(lambda: json_data['file_url']) \\\n .values(lambda: 'https://safebooru.org/index.php?page=post&s=view&id='+json_data['id']) \\\n .values(lambda: json_data['source'])\n\n",
    "tumblr": "#\n# Rules for Tumblr\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/tumblr/'))\n\ng.tags(name = 'tumblr generated tags', tagRepos = defTagRepos) \\\n .values(lambda: 'tumblr blog:'+json_data['blog_name'])\n\ng.tags(name = 'tumblr tags', tagRepos = defTagRepos, allowNoResult = True) \\\n .values(lambda: json_data['tags'])\n\ng.urls(name = 'tumblr URLs', allowEmpty = True) \\\n .values(lambda: json_data['short_url']) \\\n .values(lambda: json_data['post_url']) \\\n .values(lambda: json_data['photo']['url'] if 'photo' in json_data else '') \\\n .values(lambda: json_data['image_permalink'] if 'image_permalink' in json_data else '')\n\n",
    "fantia": "#\n# Rules for Fantia\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/fantia/'))\n\ng.tags(name = 'fantia generated tags', tagRepos = defTagRepos, allowEmpty = True) \\\n .values(lambda: ('title:'+json_data['content_title'] if 'content_tile' in json_data and json_data['content_title'] else '')) \\\n .values(lambda: 'title:'+json_data['post_title']) \\\n .values(lambda: 'rating:'+json_data['rating']) \\\n .values(lambda: 'fantia user id:'+str(json_data['fanclub_user_id'])) \\\n .values(lambda: 'creator:'+json_data['fanclub_user_name']) \\\n .values(lambda: 'fantia id:'+str(json_data['post_id']))\n\ng.urls(name = 'fantia URLs') \\\n .values(lambda: json_data['post_url']) \\\n .values(lambda: json_data['file_url'])\n\n",
    "fanbox": "#\n# Rules for Fanbox\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/fanbox/'))\n\ng.tags(name = 'fanbox generated tags', tagRepos = defTagRepos, allowEmpty = True) \\\n .values(lambda: 'creator:'+json_data['creatorId']) \\\n .values(lambda: 'fanbox id:'+json_data['id']) \\\n .values(lambda: 'title:'+json_data['title']) \\\n .values(lambda: 'creator:'+json_data['user']['name']) \\\n .values(lambda: 'fanbox user id:'+json_data['user']['userId'])\n\ng.tags(name = 'fanbox tags', tagRepos = defTagRepos, allowNoResult = True) \\\n .values(lambda: json_data['tags'])\n\ng.urls(name = 'fanbox URLs', allowEmpty = True) \\\n .values(lambda: json_data['coverImageUrl'] if json_data['isCoverImage'] else '') \\\n .values(lambda: json_data['fileUrl']) \\\n .values(lambda: 'https://'+json_data['creatorId']+'.fanbox.cc/posts/'+json_data['id'])\n\n",
    "lolibooru": "#\n# Rules for lolibooru\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/lolibooru/'))\n\ng.tags(name = 'lolibooru generated tags', tagRepos = defTagRepos) \\\n .values(lambda: 'lolibooru id:'+str(json_data['id'])) \\\n .values(lambda: 'booru:lolibooru') \\\n .values(lambda: 'rating:'+json_data['rating'])\n\ng.tags(name = 'lolibooru tags', tagRepos = defTagRepos) \\\n .values(lambda: map(lambda x: x.strip().replace('_', ' '),json_data['tags'].strip().split(' ')))\n\ng.urls(name = 'lolibooru URLs', allowEmpty = True) \\\n .values(lambda: json_data['file_url']) \\\n .values(lambda: 'https://lolibooru.moe/post/show/'+str(json_data['id'])) \\\n .values(lambda: json_data['source'])\n\n",
    "yandere": "#\n# Rules for yande.re\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/yandere/'))\n\ng.tags(name = 'yandere generated tags', tagRepos = defTagRepos) \\\n .values(lambda: 'yandere id:'+str(json_data['id'])) \\\n .values(lambda: 'booru:yande.re') \\\n .values(lambda: 'rating:'+json_data['rating'])\n\ng.tags(name = 'yandere tags', tagRepos = defTagRepos) \\\n .values(lambda: map(lambda x: x.strip().replace('_', ' '),json_data['tags'].strip().split(' ')))\n\ng.urls(name = 'yandere URLs', allowEmpty = True) \\\n .values(lambda: json_data['file_url']) \\\n .values(lambda: 'https://yande.re/post/show/'+str(json_data['id'])) \\\n .values(lambda: json_data['source'])\n\n",
    "artstation": "#\n# Rules for Artstation\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/artstation/'))\n\ng.tags(name = 'artstation generated tags', tagRepos = defTagRepos, allowEmpty = True) \\\n .values(lambda: 'medium:'+json_data['medium']['name'] if json_data['medium'] else '') \\\n .values(lambda: ['medium:'+med['name'] for med in json_data['mediums']]) \\\n .values(lambda: ['software:'+soft['name'] for soft in json_data['software_items']]) \\\n .values(lambda: ['artstation category:'+cat['name'] for cat in json_data['categories']]) \\\n .values(lambda: ('creator:'+json_data['user']['full_name']) if json_data['user']['full_name'] else '') \\\n .values(lambda: 'creator:'+json_data['user']['username']) \\\n .values(lambda: 'title:'+json_data['title'])\n\ng.tags(name = 'artstation tags', tagRepos = defTagRepos, allowNoResult = True) \\\n .values(lambda: json_data['tags'])\n\ng.urls(name = 'artstation asset image URL', allowEmpty = True) \\\n .values(lambda: json_data['asset']['image_url'])\n\ng.urls(name = 'artstation permalink', allowEmpty = True) \\\n .values(lambda: json_data['permalink'])\n\n",
    "imgur": "#\n# Rules for imgur\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/imgur/'))\n\ng.tags(name = 'imgur album title', tagRepos = defTagRepos, allowEmpty = True) \\\n .values(lambda: ('title:'+json_data['album']['title']) if 'album' in json_data and json_data['album']['title'] else '')\n\ng.tags(name = 'imgur title', tagRepos = defTagRepos, allowEmpty = True) \\\n .values(lambda: ('title:'+json_data['title']) if json_data['title'] and json_data['title'].strip() else '')\n\ng.urls(name = 'imgur image URL') \\\n .values(lambda: json_data['url'])\n\ng.urls(name = 'imgur album URL', allowEmpty = True) \\\n .values(lambda: json_data['album']['url'] if 'album' in json_data else '')\n\n",
    "seisoParty": "#\n# Rules for seiso.party\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/seisoparty/'))\n\ng.tags(name = 'seisoparty generated tags', tagRepos = defTagRepos) \\\n .values(lambda: 'title:'+json_data['title']) \\\n .values(lambda: 'creator:'+json_data['username']) \\\n .values(lambda: 'seiso.party service:'+json_data['service']) \\\n .values(lambda: 'seiso.party id:'+json_data['id']) \\\n .values(lambda: 'seiso.party user id:'+json_data['user'])\n\n",
    "rule34xxx": "#\n# Rules for rule34.xxx\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/rule34/'))\n\ng.tags(name = 'rule34 generated tags', tagRepos = defTagRepos, allowEmpty = True) \\\n .values(lambda: 'rule34 id:'+json_data['id']) \\\n .values(lambda: 'booru:rule34') \\\n .values(lambda: 'rating:'+json_data['rating'])\n\ndef rule34_tags(jd):\n    tags_from_namespaced_keys = [(key+':'+tag if key != 'general' else tag) for (key, tag) in get_namespaces_tags(jd, 'tags_')]\n    if tags_from_namespaced_keys:\n        return tags_from_namespaced_keys # the JSON contained tags_<namespace> keys. if present, those will have all the tags\n    # otherwise try just \"tags\"\n    if 'tags' in jd:\n        return map(lambda x: x.strip().replace('_', ' '), jd['tags'].strip().split(' '))\n    return []\nImportJob.f_rule34_tags = rule34_tags\n\ng.tags(name = 'rule34 tags', tagRepos = defTagRepos, allowTagsEndingWithColon = True) \\\n .values(lambda: ImportJob.f_rule34_tags(json_data))\n\ng.urls(name = 'rule34 urls', allowEmpty = True) \\\n .values(lambda: json_data['file_url']) \\\n .values(lambda: 'https://rule34.xxx/index.php?page=post&s=view&id='+json_data['id']) \\\n .values(lambda: json_data['source'])\n\n",
    "e621": "#\n# Rules for e621\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/e621/'))\n\ng.tags(name = 'e621 generated tags', tagRepos = defTagRepos, allowEmpty = True) \\\n .values(lambda: 'e621 id:' + str(json_data['id'])) \\\n .values(lambda: 'booru:e621') \\\n .values(lambda: 'rating:' + json_data['rating'])\n\ng.tags(name = 'e621 tags', tagRepos = defTagRepos, allowTagsEndingWithColon = True) \\\n .values(lambda: get_nested_tags_e621(json_data['tags']))\n\ng.tags(name = 'e621 post tags', tagRepos = defTagRepos, allowTagsEndingWithColon = True) \\\n .values(lambda: get_nested_tags_e621(json_data['tags']))\n\ng.urls(name = 'e621 urls', allowEmpty = True) \\\n .values(lambda: json_data['gallerydl_file_url']) \\\n .values(lambda: 'https://e621.net/posts/' + str(json_data['id']))\n\n",
    "furaffinity": "#\n# Rules for Furaffinity\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/furaffinity/'))\n\ng.tags(name = 'furaffinity generated tags', tagRepos = defTagRepos, allowEmpty = True) \\\n .values(lambda: 'furaffinity id:'+str(json_data['id'])) \\\n .values(lambda: 'booru:furaffinity') \\\n .values(lambda: 'rating:'+json_data['rating']) \\\n .values(lambda: 'creator:'+json_data['artist']) \\\n .values(lambda: 'title:'+json_data['title']) \\\n .values(lambda: ('gender:'+json_data['gender']) if json_data['gender'] != 'Any' else '') \\\n .values(lambda: ('species:'+json_data['species']) if json_data['species'] != 'Unspecified / Any' else '')\n\ng.tags(name = 'furaffinity tags', tagRepos = defTagRepos, allowNoResult = True, allowEmpty = True, allowTagsEndingWithColon = True) \\\n .values(lambda: [tag.replace('_', ' ') for tag in json_data['tags']])\n\ng.urls(name = 'furaffinity urls', allowEmpty = True) \\\n .values(lambda: json_data['url']) \\\n .values(lambda: 'https://www.furaffinity.net/view/'+str(json_data['id'])+'/')\n\n",
    "instagram": "#\n# Rules for Instagram\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/instagram/'))\n\ng.tags(name = 'instagram generated tags', tagRepos = defTagRepos, allowNoResult = True, allowEmpty = True, allowTagsEndingWithColon = True) \\\n .values(lambda: 'creator:'+json_data['username']) \\\n .values(lambda: 'name:'+json_data['fullname']) \\\n .values(lambda: 'type:'+json_data['subcategory']) \\\n .values(lambda: 'title:'+json_data['description']) \\\n .values(lambda: 'instagram shortcode:'+json_data['shortcode']) \\\n .values(lambda: 'source:'+str(json_data['category'])) \\\n .values(lambda: 'page:'+str(json_data['num']) if json_data['count'] > 1 else '')\n\ng.urls(name = 'instagram urls') \\\n .values(lambda: 'https://www.instagram.com/p/'+str(json_data['shortcode']))\n\n",
    "redgifs": "#\n# Rules for redgifs\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/redgifs/'))\n\ng.tags(name = 'redgifs generated tags', tagRepos = defTagRepos, allowNoResult = True, allowEmpty = True) \\\n .values(lambda: 'creator:'+json_data['userName']) \\\n .values(lambda: 'redgifs id:'+json_data['filename']) \\\n .values(lambda: 'source:'+str(json_data['category']))\n\ng.tags(name = 'redgifs tags', tagRepos = defTagRepos, allowNoResult = True, allowEmpty = True, allowTagsEndingWithColon = True) \\\n .values(lambda: [tag.replace('_', ' ') for tag in json_data['tags']])\n\ng.urls(name = 'redgifs urls') \\\n .values(lambda: 'https://www.redgifs.com/watch/'+str(json_data['filename']))\n\n",
    "tiktok": "#\n# Rules for tiktok\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/tiktok/'))\n\ng.tags(name = 'tiktok generated tags', tagRepos = defTagRepos, allowNoResult = True, allowEmpty = True) \\\n .values(lambda: 'creator:'+json_data['author']['uniqueId']) \\\n .values(lambda: 'name:'+json_data['author']['nickname']) \\\n .values(lambda: 'tiktok id:'+str(json_data['id'])) \\\n .values(lambda: 'source:'+str(json_data['category'])) \\\n .values(lambda: 'title:'+json_data['title'])\n\ng.urls(name = 'tiktok urls') \\\n .values(lambda: 'https://www.tiktok.com/@'+str(json_data['author']['uniqueId'])+'/video/'+str(json_data['id']))\n\n",
    "reddit": "#\n# Rules for reddit\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/reddit/'))\n\ng.tags(name = 'reddit generated tags', tagRepos = defTagRepos, allowNoResult = True, allowEmpty = True) \\\n .values(lambda: 'subreddit:' + json_data['subreddit_name_prefixed'] if json_data.get('subreddit_type') != 'user' else '') \\\n .values(lambda: 'creator:'+json_data['author']) \\\n .values(lambda: 'reddit id:'+str(json_data['id'])) \\\n .values(lambda: 'source:'+str(json_data['category'])) \\\n .values(lambda: 'title:'+json_data['title']) \\\n .values(lambda: 'site:reddit')\n\ng.urls(name = 'reddit urls') \\\n .values(lambda: 'https://www.reddit.com/'+str(json_data['permalink'])) \\\n .values(lambda: 'https://i.redd.it/'+json_data['filename']+'.'+json_data['extension'])\n\n",
    "iwara": "#\n# Rules for Iwara\n#\n\ng = j.group(tagReposForNonUrlSources = defTagReposForNonUrlSources, filter = lambda: pstartswith(path, 'gallery-dl/iwara/'))\n\ng.tags(name = 'iwara generated tags', tagRepos = defTagRepos) \\\n .values(lambda: 'iwara id:'+json_data['id']) \\\n .values(lambda: 'creator:'+json_data['user']['name']) \\\n .values(lambda: 'creator:'+json_data['user']['nick']) \\\n .values(lambda: 'title:'+json_data['title'])\n\ng.notes(name = 'iwara post description', allowEmpty = True) \\\n .values(lambda: \"iwara post description\\n\"+str(json_data['user']['description']))\n"
  }
}